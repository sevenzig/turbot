---
description: 
globs: 
alwaysApply: false
---
# Security Best Practices for Business Websites

**Version:** 1.0  
**Scope:** React + TypeScript + Vite business websites  
**Business Context:** Professional sites handling customer data, forms, and basic e-commerce

## Overview

Security for business websites isn't just about preventing attacksâ€”it's about protecting your business reputation, customer trust, and legal compliance. Every security measure should be justified by its business value and implemented without compromising user experience.

### Business Impact Framework
- **Customer Trust:** Secure handling of personal data builds customer confidence
- **Legal Compliance:** GDPR, CCPA, and industry-specific regulations
- **Business Continuity:** Preventing downtime and data breaches
- **Reputation Protection:** Security incidents damage brand reputation
- **Cost Avoidance:** Prevention is cheaper than incident response

---

## 1. Input Validation & Sanitization

### Form Input Validation

**Business Context:** Contact forms, newsletter signups, and booking forms are prime attack vectors. Invalid data can break functionality and expose vulnerabilities.

```typescript
// types/validation.ts
interface ValidationRule {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  sanitize?: boolean;
}

interface ValidationSchema {
  [key: string]: ValidationRule;
}

// Contact form validation schema
export const contactFormSchema: ValidationSchema = {
  name: {
    required: true,
    minLength: 2,
    maxLength: 100,
    pattern: /^[a-zA-Z\s'-]+$/,
    sanitize: true
  },
  email: {
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    maxLength: 254
  },
  phone: {
    pattern: /^[\+]?[1-9][\d]{0,15}$/,
    maxLength: 20
  },
  message: {
    required: true,
    minLength: 10,
    maxLength: 2000,
    sanitize: true
  }
};
```

```typescript
// utils/inputValidation.ts
import DOMPurify from 'dompurify';

export class InputValidator {
  static validateField(value: string, rule: ValidationRule): {
    isValid: boolean;
    error?: string;
    sanitizedValue?: string;
  } {
    // Required field check
    if (rule.required && (!value || value.trim().length === 0)) {
      return { isValid: false, error: 'This field is required' };
    }

    // Length validation
    if (rule.minLength && value.length < rule.minLength) {
      return { 
        isValid: false, 
        error: `Minimum ${rule.minLength} characters required` 
      };
    }

    if (rule.maxLength && value.length > rule.maxLength) {
      return { 
        isValid: false, 
        error: `Maximum ${rule.maxLength} characters allowed` 
      };
    }

    // Pattern validation
    if (rule.pattern && !rule.pattern.test(value)) {
      return { isValid: false, error: 'Invalid format' };
    }

    // Sanitization
    const sanitizedValue = rule.sanitize ? 
      DOMPurify.sanitize(value, { ALLOWED_TAGS: [] }) : value;

    return { isValid: true, sanitizedValue };
  }

  static validateForm(formData: Record<string, string>, schema: ValidationSchema) {
    const errors: Record<string, string> = {};
    const sanitizedData: Record<string, string> = {};

    Object.entries(formData).forEach(([field, value]) => {
      const rule = schema[field];
      if (rule) {
        const result = this.validateField(value, rule);
        if (!result.isValid) {
          errors[field] = result.error!;
        } else {
          sanitizedData[field] = result.sanitizedValue || value;
        }
      }
    });

    return {
      isValid: Object.keys(errors).length === 0,
      errors,
      sanitizedData
    };
  }
}
```

### XSS Prevention for User Content

```typescript
// components/SafeContent/SafeContent.tsx
import DOMPurify from 'dompurify';
import { useMemo } from 'react';

interface SafeContentProps {
  content: string;
  allowBasicFormatting?: boolean;
  className?: string;
}

export const SafeContent: React.FC<SafeContentProps> = ({
  content,
  allowBasicFormatting = false,
  className
}) => {
  const sanitizedContent = useMemo(() => {
    const config = allowBasicFormatting ? {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br'],
      ALLOWED_ATTR: []
    } : {
      ALLOWED_TAGS: [],
      ALLOWED_ATTR: []
    };

    return DOMPurify.sanitize(content, config);
  }, [content, allowBasicFormatting]);

  return (
    <div 
      className={className}
      dangerouslySetInnerHTML={{ __html: sanitizedContent }}
    />
  );
};
```

### URL Parameter Validation

```typescript
// utils/urlValidation.ts
export class URLValidator {
  private static readonly ALLOWED_PARAMS = new Set([
    'page', 'category', 'search', 'filter', 'sort', 'utm_source', 'utm_medium'
  ]);

  static validateQueryParams(searchParams: URLSearchParams): URLSearchParams {
    const cleanParams = new URLSearchParams();

    searchParams.forEach((value, key) => {
      // Check if parameter is allowed
      if (!this.ALLOWED_PARAMS.has(key)) {
        console.warn(`Rejected parameter: ${key}`);
        return;
      }

      // Sanitize parameter value
      const sanitizedValue = DOMPurify.sanitize(value, { ALLOWED_TAGS: [] });
      
      // Additional validation based on parameter type
      if (this.isValidParamValue(key, sanitizedValue)) {
        cleanParams.set(key, sanitizedValue);
      }
    });

    return cleanParams;
  }

  private static isValidParamValue(key: string, value: string): boolean {
    switch (key) {
      case 'page':
        return /^\d+$/.test(value) && parseInt(value) > 0;
      case 'category':
        return /^[a-zA-Z0-9-_]+$/.test(value) && value.length <= 50;
      case 'search':
        return value.length <= 100;
      default:
        return value.length <= 200;
    }
  }
}
```

---

## 2. Authentication & Authorization

### JWT Token Handling

```typescript
// utils/authToken.ts
interface TokenPayload {
  userId: string;
  email: string;
  role: 'admin' | 'user';
  exp: number;
}

export class AuthTokenManager {
  private static readonly TOKEN_KEY = 'business_auth_token';
  private static readonly REFRESH_KEY = 'business_refresh_token';

  static setTokens(accessToken: string, refreshToken: string): void {
    // Store tokens in httpOnly cookies when possible
    // Fallback to secure localStorage for client-side apps
    if (this.isSecureContext()) {
      document.cookie = `${this.TOKEN_KEY}=${accessToken}; Secure; HttpOnly; SameSite=Strict; Max-Age=3600`;
      document.cookie = `${this.REFRESH_KEY}=${refreshToken}; Secure; HttpOnly; SameSite=Strict; Max-Age=604800`;
    } else {
      // Development fallback
      localStorage.setItem(this.TOKEN_KEY, accessToken);
      localStorage.setItem(this.REFRESH_KEY, refreshToken);
    }
  }

  static getToken(): string | null {
    try {
      return localStorage.getItem(this.TOKEN_KEY);
    } catch {
      return null;
    }
  }

  static validateToken(token: string): boolean {
    try {
      const payload = this.parseJWT(token);
      return payload.exp > Date.now() / 1000;
    } catch {
      return false;
    }
  }

  static parseJWT(token: string): TokenPayload {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  }

  static clearTokens(): void {
    localStorage.removeItem(this.TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_KEY);
    // Clear cookies if used
    document.cookie = `${this.TOKEN_KEY}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    document.cookie = `${this.REFRESH_KEY}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
  }

  private static isSecureContext(): boolean {
    return window.location.protocol === 'https:' || window.location.hostname === 'localhost';
  }
}
```

### Role-Based Access Control

```typescript
// hooks/useAuth.ts
import { useState, useEffect, createContext, useContext } from 'react';

interface AuthUser {
  id: string;
  email: string;
  role: 'admin' | 'user';
  permissions: string[];
}

interface AuthContextType {
  user: AuthUser | null;
  login: (email: string, password: string) => Promise<boolean>;
  logout: () => void;
  hasPermission: (permission: string) => boolean;
  loading: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

// components/ProtectedRoute/ProtectedRoute.tsx
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredPermission?: string;
  requiredRole?: 'admin' | 'user';
  fallback?: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  requiredPermission,
  requiredRole,
  fallback = <div>Access Denied</div>
}) => {
  const { user, hasPermission } = useAuth();

  if (!user) {
    return <div>Please log in to access this content</div>;
  }

  if (requiredRole && user.role !== requiredRole) {
    return fallback;
  }

  if (requiredPermission && !hasPermission(requiredPermission)) {
    return fallback;
  }

  return <>{children}</>;
};
```

---

## 3. Data Protection & Privacy

### GDPR Compliance Framework

```typescript
// types/privacy.ts
export interface ConsentPreferences {
  necessary: boolean; // Always true, cannot be disabled
  analytics: boolean;
  marketing: boolean;
  personalization: boolean;
}

export interface PrivacyData {
  userId?: string;
  consentTimestamp: Date;
  consentVersion: string;
  preferences: ConsentPreferences;
  ipAddress?: string; // Anonymized
  userAgent?: string; // Anonymized
}

// utils/privacyManager.ts
export class PrivacyManager {
  private static readonly CONSENT_KEY = 'gdpr_consent';
  private static readonly CONSENT_VERSION = '1.0';

  static recordConsent(preferences: ConsentPreferences): void {
    const consentData: PrivacyData = {
      consentTimestamp: new Date(),
      consentVersion: this.CONSENT_VERSION,
      preferences,
      // Store anonymized data only
      ipAddress: this.anonymizeIP(this.getClientIP()),
      userAgent: this.anonymizeUserAgent(navigator.userAgent)
    };

    localStorage.setItem(this.CONSENT_KEY, JSON.stringify(consentData));
    this.applyConsentPreferences(preferences);
  }

  static getConsent(): PrivacyData | null {
    try {
      const stored = localStorage.getItem(this.CONSENT_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  }

  static hasValidConsent(): boolean {
    const consent = this.getConsent();
    if (!consent) return false;

    // Check if consent is still valid (e.g., within last year)
    const consentAge = Date.now() - new Date(consent.consentTimestamp).getTime();
    const maxAge = 365 * 24 * 60 * 60 * 1000; // 1 year
    
    return consentAge < maxAge && consent.consentVersion === this.CONSENT_VERSION;
  }

  private static applyConsentPreferences(preferences: ConsentPreferences): void {
    // Configure analytics
    if (preferences.analytics) {
      // Initialize analytics tracking
      this.initializeAnalytics();
    } else {
      // Disable analytics
      this.disableAnalytics();
    }

    // Configure marketing tools
    if (preferences.marketing) {
      this.initializeMarketing();
    } else {
      this.disableMarketing();
    }
  }

  private static anonymizeIP(ip: string): string {
    // Simple IP anonymization - remove last octet
    return ip.split('.').slice(0, 3).join('.') + '.0';
  }

  private static anonymizeUserAgent(ua: string): string {
    // Remove version numbers and specific identifiers
    return ua.replace(/\/[\d.]+/g, '/*').substring(0, 100);
  }

  // Data deletion for GDPR right to be forgotten
  static deleteUserData(userId: string): Promise<boolean> {
    // Implementation would depend on your backend
    return fetch('/api/privacy/delete-user-data', {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId })
    }).then(response => response.ok);
  }
}
```

### Secure API Communication

```typescript
// utils/secureApiClient.ts
interface ApiConfig {
  baseURL: string;
  timeout: number;
  retries: number;
}

export class SecureApiClient {
  private config: ApiConfig;
  private readonly RATE_LIMIT_STORAGE_KEY = 'api_rate_limit';

  constructor(config: ApiConfig) {
    this.config = config;
  }

  async request<T>(
    endpoint: string, 
    options: RequestInit = {}
  ): Promise<T> {
    // Check rate limiting
    if (!this.checkRateLimit()) {
      throw new Error('Rate limit exceeded. Please try again later.');
    }

    // Ensure HTTPS
    const url = this.ensureHTTPS(`${this.config.baseURL}${endpoint}`);
    
    const secureOptions: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest', // CSRF protection
        ...options.headers,
        ...(AuthTokenManager.getToken() && {
          'Authorization': `Bearer ${AuthTokenManager.getToken()}`
        })
      },
      credentials: 'same-origin', // CSRF protection
      mode: 'cors',
      cache: 'no-store' // Prevent sensitive data caching
    };

    try {
      const response = await fetch(url, secureOptions);
      
      // Update rate limit tracking
      this.updateRateLimit();

      if (!response.ok) {
        throw new Error(`API Error: ${response.status}`);
      }

      // Validate response content type
      const contentType = response.headers.get('content-type');
      if (!contentType?.includes('application/json')) {
        throw new Error('Invalid response format');
      }

      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  private ensureHTTPS(url: string): string {
    if (url.startsWith('http://') && !url.includes('localhost')) {
      return url.replace('http://', 'https://');
    }
    return url;
  }

  private checkRateLimit(): boolean {
    const stored = localStorage.getItem(this.RATE_LIMIT_STORAGE_KEY);
    if (!stored) return true;

    const { count, timestamp } = JSON.parse(stored);
    const now = Date.now();
    const timeWindow = 60 * 1000; // 1 minute
    const maxRequests = 30; // 30 requests per minute

    if (now - timestamp > timeWindow) {
      // Reset window
      return true;
    }

    return count < maxRequests;
  }

  private updateRateLimit(): void {
    const stored = localStorage.getItem(this.RATE_LIMIT_STORAGE_KEY);
    const now = Date.now();

    if (!stored) {
      localStorage.setItem(this.RATE_LIMIT_STORAGE_KEY, 
        JSON.stringify({ count: 1, timestamp: now }));
      return;
    }

    const { count, timestamp } = JSON.parse(stored);
    const timeWindow = 60 * 1000; // 1 minute

    if (now - timestamp > timeWindow) {
      // Reset window
      localStorage.setItem(this.RATE_LIMIT_STORAGE_KEY, 
        JSON.stringify({ count: 1, timestamp: now }));
    } else {
      // Increment counter
      localStorage.setItem(this.RATE_LIMIT_STORAGE_KEY, 
        JSON.stringify({ count: count + 1, timestamp }));
    }
  }
}
```

---

## 4. Client-Side Security

### Content Security Policy

```typescript
// utils/cspConfig.ts
export const generateCSPHeader = (): string => {
  const cspDirectives = {
    'default-src': ["'self'"],
    'script-src': [
      "'self'",
      "'unsafe-inline'", // Required for Vite in development
      'https://www.google-analytics.com',
      'https://www.googletagmanager.com'
    ],
    'style-src': [
      "'self'",
      "'unsafe-inline'", // Required for CSS-in-JS
      'https://fonts.googleapis.com'
    ],
    'font-src': [
      "'self'",
      'https://fonts.gstatic.com'
    ],
    'img-src': [
      "'self'",
      'data:',
      'https:',
      'blob:'
    ],
    'connect-src': [
      "'self'",
      'https://api.yourbusiness.com',
      'https://www.google-analytics.com'
    ],
    'frame-ancestors': ["'none'"],
    'base-uri': ["'self'"],
    'form-action': ["'self'"]
  };

  return Object.entries(cspDirectives)
    .map(([directive, sources]) => `${directive} ${sources.join(' ')}`)
    .join('; ');
};

// vite.config.ts addition for CSP headers
export default defineConfig({
  // ... existing config
  plugins: [
    react(),
    {
      name: 'csp-headers',
      configureServer(server) {
        server.middlewares.use((req, res, next) => {
          if (req.url?.endsWith('.html')) {
            res.setHeader('Content-Security-Policy', generateCSPHeader());
            res.setHeader('X-Frame-Options', 'DENY');
            res.setHeader('X-Content-Type-Options', 'nosniff');
            res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
          }
          next();
        });
      }
    }
  ]
});
```

### Secure Cookie Configuration

```typescript
// utils/cookieManager.ts
interface CookieOptions {
  expires?: Date;
  maxAge?: number;
  secure?: boolean;
  httpOnly?: boolean;
  sameSite?: 'strict' | 'lax' | 'none';
}

export class SecureCookieManager {
  static set(name: string, value: string, options: CookieOptions = {}): void {
    const defaultOptions: Required<CookieOptions> = {
      expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
      maxAge: 24 * 60 * 60, // 24 hours in seconds
      secure: window.location.protocol === 'https:',
      httpOnly: false, // Cannot be set from client-side JS
      sameSite: 'strict'
    };

    const finalOptions = { ...defaultOptions, ...options };
    
    let cookieString = `${name}=${encodeURIComponent(value)}`;
    
    if (finalOptions.expires) {
      cookieString += `; expires=${finalOptions.expires.toUTCString()}`;
    }
    
    if (finalOptions.maxAge) {
      cookieString += `; max-age=${finalOptions.maxAge}`;
    }
    
    if (finalOptions.secure) {
      cookieString += '; secure';
    }
    
    cookieString += `; samesite=${finalOptions.sameSite}`;
    cookieString += '; path=/';

    document.cookie = cookieString;
  }

  static get(name: string): string | null {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    
    if (parts.length === 2) {
      const cookieValue = parts.pop()?.split(';').shift();
      return cookieValue ? decodeURIComponent(cookieValue) : null;
    }
    
    return null;
  }

  static delete(name: string): void {
    document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
  }
}
```

---

## 5. Business-Specific Security

### Contact Form Security

```typescript
// components/ContactForm/ContactForm.tsx
import { useState } from 'react';
import { contactFormSchema } from '@/types/validation';
import { InputValidator } from '@/utils/inputValidation';

interface ContactFormData {
  name: string;
  email: string;
  phone: string;
  message: string;
  honeypot: string; // Bot detection field
}

export const ContactForm: React.FC = () => {
  const [formData, setFormData] = useState<ContactFormData>({
    name: '',
    email: '',
    phone: '',
    message: '',
    honeypot: ''
  });
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitCount, setSubmitCount] = useState(0);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Honeypot check - bots will fill this hidden field
    if (formData.honeypot) {
      console.warn('Bot detected via honeypot');
      return;
    }

    // Rate limiting check
    if (submitCount >= 3) {
      setErrors({ general: 'Too many attempts. Please wait before trying again.' });
      return;
    }

    // Validate form data
    const validation = InputValidator.validateForm(formData, contactFormSchema);
    
    if (!validation.isValid) {
      setErrors(validation.errors);
      return;
    }

    setIsSubmitting(true);
    setErrors({});

    try {
      // Use sanitized data
      const response = await fetch('/api/contact', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify({
          ...validation.sanitizedData,
          timestamp: Date.now(), // For duplicate detection
          userAgent: navigator.userAgent.substring(0, 100) // Limited UA string
        })
      });

      if (!response.ok) {
        throw new Error('Failed to submit form');
      }

      // Success handling
      setFormData({ name: '', email: '', phone: '', message: '', honeypot: '' });
      setSubmitCount(prev => prev + 1);
      
    } catch (error) {
      setErrors({ general: 'Failed to send message. Please try again.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="contact-form">
      {/* Honeypot field - hidden from users */}
      <input
        type="text"
        name="website"
        value={formData.honeypot}
        onChange={(e) => setFormData(prev => ({ ...prev, honeypot: e.target.value }))}
        style={{ display: 'none' }}
        tabIndex={-1}
        autoComplete="off"
      />
      
      {/* Rest of form fields */}
      <div className="form-group">
        <label htmlFor="name">Name *</label>
        <input
          type="text"
          id="name"
          value={formData.name}
          onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
          required
        />
        {errors.name && <span className="error">{errors.name}</span>}
      </div>

      {/* Additional form fields... */}
      
      <button 
        type="submit" 
        disabled={isSubmitting || submitCount >= 3}
      >
        {isSubmitting ? 'Sending...' : 'Send Message'}
      </button>
      
      {errors.general && <div className="error">{errors.general}</div>}
    </form>
  );
};
```

### Admin Panel Security

```typescript
// components/AdminPanel/AdminPanel.tsx
import { useAuth } from '@/hooks/useAuth';
import { ProtectedRoute } from '@/components/ProtectedRoute/ProtectedRoute';

export const AdminPanel: React.FC = () => {
  const { user } = useAuth();

  return (
    <ProtectedRoute requiredRole="admin">
      <div className="admin-panel">
        <header className="admin-header">
          <h1>Business Admin Panel</h1>
          <div className="user-info">
            Logged in as: {user?.email}
          </div>
        </header>
        
        <nav className="admin-nav">
          <ProtectedRoute requiredPermission="manage_content">
            <button>Manage Content</button>
          </ProtectedRoute>
          
          <ProtectedRoute requiredPermission="view_analytics">
            <button>View Analytics</button>
          </ProtectedRoute>
          
          <ProtectedRoute requiredPermission="manage_users">
            <button>Manage Users</button>
          </ProtectedRoute>
        </nav>
      </div>
    </ProtectedRoute>
  );
};
```

---

## 6. Security Testing Patterns

### Security Test Suite

```typescript
// test/security.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ContactForm } from '@/components/ContactForm/ContactForm';
import { InputValidator } from '@/utils/inputValidation';
import { AuthTokenManager } from '@/utils/authToken';

describe('Security Tests', () => {
  describe('Input Validation', () => {
    test('should reject XSS attempts in form inputs', () => {
      const xssPayload = '<script>alert("xss")</script>';
      const result = InputValidator.validateField(xssPayload, {
        required: true,
        sanitize: true
      });
      
      expect(result.sanitizedValue).not.toContain('<script>');
      expect(result.sanitizedValue).toBe('');
    });

    test('should validate email format correctly', () => {
      const invalidEmails = [
        'invalid-email',
        '@example.com',
        'test@',
        'test..test@example.com'
      ];

      invalidEmails.forEach(email => {
        const result = InputValidator.validateField(email, {
          pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        });
        expect(result.isValid).toBe(false);
      });
    });
  });

  describe('Authentication', () => {
    test('should handle invalid JWT tokens', () => {
      const invalidToken = 'invalid.jwt.token';
      expect(AuthTokenManager.validateToken(invalidToken)).toBe(false);
    });

    test('should handle expired tokens', () => {
      // Create an expired token (simplified for testing)
      const expiredPayload = {
        userId: 'test',
        email: 'test@example.com',
        role: 'user' as const,
        exp: Math.floor(Date.now() / 1000) - 3600 // 1 hour ago
      };
      
      // This would be a real JWT in practice
      const expiredToken = btoa(JSON.stringify(expiredPayload));
      expect(AuthTokenManager.validateToken(expiredToken)).toBe(false);
    });
  });

  describe('Contact Form Security', () => {
    test('should reject form submission with honeypot filled', async () => {
      render(<ContactForm />);
      
      // Fill honeypot field (hidden from users but bots might fill it)
      const honeypotField = screen.getByDisplayValue('');
      fireEvent.change(honeypotField, { target: { value: 'bot-content' } });
      
      const submitButton = screen.getByText('Send Message');
      fireEvent.click(submitButton);
      
      // Form should not submit (no API call should be made)
      await waitFor(() => {
        expect(screen.queryByText('Sending...')).not.toBeInTheDocument();
      });
    });

    test('should enforce rate limiting', async () => {
      render(<ContactForm />);
      
      // Simulate multiple rapid submissions
      const submitButton = screen.getByText('Send Message');
      
      for (let i = 0; i < 4; i++) {
        fireEvent.click(submitButton);
      }
      
      await waitFor(() => {
        expect(screen.getByText(/Too many attempts/)).toBeInTheDocument();
      });
    });
  });
});
```

---

## 7. Security Checklist

### Pre-Launch Security Audit

```typescript
// utils/securityAudit.ts
interface SecurityCheck {
  name: string;
  description: string;
  check: () => boolean | Promise<boolean>;
  critical: boolean;
}

export const securityChecks: SecurityCheck[] = [
  {
    name: 'HTTPS Enforcement',
    description: 'Ensure all traffic is served over HTTPS',
    check: () => window.location.protocol === 'https:' || window.location.hostname === 'localhost',
    critical: true
  },
  {
    name: 'CSP Headers',
    description: 'Content Security Policy headers are configured',
    check: async () => {
      const response = await fetch(window.location.href);
      return response.headers.get('content-security-policy') !== null;
    },
    critical: true
  },
  {
    name: 'Form Validation',
    description: 'All forms have proper validation',
    check: () => {
      const forms = document.querySelectorAll('form');
      return Array.from(forms).every(form => 
        form.querySelector('input[required]') !== null
      );
    },
    critical: true
  },
  {
    name: 'External Dependencies',
    description: 'All external scripts are from trusted sources',
    check: () => {
      const scripts = document.querySelectorAll('script[src]');
      const trustedDomains = ['www.google-analytics.com', 'www.googletagmanager.com'];
      
      return Array.from(scripts).every(script => {
        const src = script.getAttribute('src');
        if (!src) return true;
        
        return trustedDomains.some(domain => src.includes(domain)) || 
               src.startsWith('/') || 
               src.startsWith('./');
      });
    },
    critical: false
  }
];

export async function runSecurityAudit(): Promise<{
  passed: number;
  failed: number;
  critical: number;
  results: Array<{ check: SecurityCheck; passed: boolean; error?: string }>;
}> {
  const results = [];
  let passed = 0;
  let failed = 0;
  let critical = 0;

  for (const check of securityChecks) {
    try {
      const result = await check.check();
      results.push({ check, passed: result });
      
      if (result) {
        passed++;
      } else {
        failed++;
        if (check.critical) critical++;
      }
    } catch (error) {
      results.push({ 
        check, 
        passed: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
      failed++;
      if (check.critical) critical++;
    }
  }

  return { passed, failed, critical, results };
}
```

### Environment-Specific Security

```typescript
// utils/environmentSecurity.ts
export class EnvironmentSecurity {
  static validateEnvironment(): void {
    // Check for development-only features in production
    if (import.meta.env.PROD) {
      this.validateProductionSecurity();
    } else {
      this.validateDevelopmentSecurity();
    }
  }

  private static validateProductionSecurity(): void {
    // Ensure no debug information is exposed
    if (window.localStorage.getItem('debug')) {
      console.warn('Debug mode detected in production');
      window.localStorage.removeItem('debug');
    }

    // Ensure API URLs are production URLs
    const apiUrl = import.meta.env.VITE_API_URL;
    if (apiUrl && (apiUrl.includes('localhost') || apiUrl.includes('127.0.0.1'))) {
      throw new Error('Development API URL detected in production');
    }

    // Disable console in production
    if (typeof console !== 'undefined') {
      console.log = () => {};
      console.warn = () => {};
      console.error = () => {};
    }
  }

  private static validateDevelopmentSecurity(): void {
    // Development-specific security warnings
    if (!window.location.protocol.startsWith('https') && 
        !window.location.hostname.includes('localhost')) {
      console.warn('Non-HTTPS connection detected in development');
    }

    // Check for test data exposure
    if (window.localStorage.getItem('test_user_data')) {
      console.warn('Test user data found in localStorage');
    }
  }
}
```

---

## 8. Integration with Business Data

### Secure Business Info Handling

```typescript
// utils/businessDataSecurity.ts
import { businessInfo } from '@/data/businessInfo';

export class BusinessDataSecurity {
  // Sanitize business info before rendering
  static getSafeBusinessInfo() {
    return {
      ...businessInfo,
      // Sanitize any user-editable fields
      name: this.sanitizeText(businessInfo.name),
      description: this.sanitizeText(businessInfo.description),
      // Keep contact info as-is (assumed safe from setup)
      contact: businessInfo.contact,
      // Sanitize any social media links to prevent XSS
      socialMedia: businessInfo.socialMedia ? 
        Object.fromEntries(
          Object.entries(businessInfo.socialMedia).map(([key, url]) => [
            key, 
            this.sanitizeURL(url)
          ])
        ) : undefined
    };
  }

  private static sanitizeText(text: string): string {
    return text.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  }

  private static sanitizeURL(url: string): string {
    try {
      const parsedUrl = new URL(url);
      // Only allow https and http protocols
      if (!['https:', 'http:'].includes(parsedUrl.protocol)) {
        return '#';
      }
      return url;
    } catch {
      return '#';
    }
  }
}
```

---

## 9. Monitoring & Incident Response

### Security Event Logging

```typescript
// utils/securityLogger.ts
interface SecurityEvent {
  type: 'auth_failure' | 'xss_attempt' | 'rate_limit' | 'suspicious_activity';
  severity: 'low' | 'medium' | 'high' | 'critical';
  details: Record<string, any>;
  timestamp: Date;
  userIP?: string;
  userAgent?: string;
}

export class SecurityLogger {
  private static events: SecurityEvent[] = [];
  private static readonly MAX_EVENTS = 100;

  static logEvent(event: Omit<SecurityEvent, 'timestamp'>): void {
    const fullEvent: SecurityEvent = {
      ...event,
      timestamp: new Date(),
      userIP: this.getAnonymizedIP(),
      userAgent: navigator.userAgent.substring(0, 100)
    };

    this.events.push(fullEvent);
    
    // Keep only recent events
    if (this.events.length > this.MAX_EVENTS) {
      this.events = this.events.slice(-this.MAX_EVENTS);
    }

    // Log critical events to console in development
    if (!import.meta.env.PROD && event.severity === 'critical') {
      console.error('Critical security event:', fullEvent);
    }

    // In production, send to monitoring service
    if (import.meta.env.PROD && ['high', 'critical'].includes(event.severity)) {
      this.sendToMonitoring(fullEvent);
    }
  }

  static getSecurityEvents(): SecurityEvent[] {
    return [...this.events];
  }

  private static getAnonymizedIP(): string {
    // In a real application, this would be handled server-side
    return 'anonymized';
  }

  private static async sendToMonitoring(event: SecurityEvent): Promise<void> {
    try {
      await fetch('/api/security/events', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(event)
      });
    } catch (error) {
      console.error('Failed to send security event to monitoring:', error);
    }
  }
}

// Usage examples:
// SecurityLogger.logEvent({
//   type: 'auth_failure',
//   severity: 'medium',
//   details: { email: 'user@example.com', reason: 'invalid_password' }
// });
//
// SecurityLogger.logEvent({
//   type: 'xss_attempt',
//   severity: 'high',
//   details: { field: 'contact_message', payload: '<script>...' }
// });
```

---

## Implementation Priority

### Phase 1: Critical Security (Immediate)
1. Input validation and sanitization
2. HTTPS enforcement
3. Basic authentication security
4. Form security (honeypot, rate limiting)

### Phase 2: Enhanced Protection (Week 2)
1. CSP headers implementation
2. JWT token security
3. Privacy compliance basics
4. Security testing suite

### Phase 3: Advanced Features (Week 3-4)
1. Comprehensive audit logging
2. Advanced rate limiting
3. Admin panel security
4. Monitoring integration

### Phase 4: Maintenance (Ongoing)
1. Regular security audits
2. Dependency updates
3. Penetration testing
4. Incident response procedures

---

## Business Value Summary

- **Customer Trust:** Secure handling of customer data builds confidence in your business
- **Legal Compliance:** GDPR and privacy law compliance protects against fines
- **SEO Benefits:** Google favors secure sites in search rankings
- **Cost Savings:** Prevention is 10x cheaper than incident response
- **Professional Image:** Security demonstrates business professionalism
- **Competitive Advantage:** Many small business websites lack proper security

**Remember:** Security is not a one-time implementation but an ongoing business process that protects your most valuable assetâ€”customer trust.

